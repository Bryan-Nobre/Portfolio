<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <title>pixelate</title>
</head>

<style>
body {
  margin: 0;
  background-color: var(--bg);
  color: var(--text);
  transition: background-color 0.4s ease, color 0.4s ease;
}

body.light {
  --bg: #ffffff;
  --text: #000000;
}

body.dark {
  --bg: #121212;
  --text: #ffffff;
}

.rope-container {
  position: fixed;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  z-index: 999;
}


</style>

<body>

  <div class="rope-container">
    <canvas id="ropeCanvas" width="1000" height="1000"></canvas>
  </div>

  <script>
const canvas = document.getElementById("ropeCanvas");
const ctx = canvas.getContext("2d");

let origin = { x: canvas.width / 2, y: 0 };
let handle = { x: canvas.width / 2, y: 150 };
let velocity = { x: 0, y: 0 };
let isDragging = false;
let friction = 0.9;
let spring = 0.1;
let pulled = false;

canvas.addEventListener("mousedown", (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const dx = x - handle.x;
  const dy = y - handle.y;

  if (Math.sqrt(dx * dx + dy * dy) < 30) {
    isDragging = true;
  }
});

canvas.addEventListener("mouseup", () => {
  if (isDragging && handle.y > 220 && !pulled) {
    toggleTheme();
    pulled = true;
    setTimeout(() => pulled = false, 1000); // cooldown
  }
  isDragging = false;
});

canvas.addEventListener("mousemove", (e) => {
  if (isDragging) {
    const rect = canvas.getBoundingClientRect();
    handle.x = e.clientX - rect.left;
    handle.y = e.clientY - rect.top;
  }
});

function toggleTheme() {
  const body = document.body;
  const isDark = body.classList.contains("dark");
  body.classList.toggle("dark", !isDark);
  body.classList.toggle("light", isDark);
  localStorage.setItem("theme", !isDark ? "dark" : "light");

  // Som
  const audio = new Audio("https://freesound.org/data/previews/256/256113_3263906-lq.mp3");
  audio.volume = 0.5;
  audio.play();
}


function restoreTheme() {
  const saved = localStorage.getItem("theme") || "light";
  document.body.classList.add(saved);
}

function updatePhysics() {
  if (!isDragging) {
    // forÃ§ar retorno para o centro (efeito mola)
    let forceX = (origin.x - handle.x) * spring;
    let forceY = (origin.y + 150 - handle.y) * spring;

    velocity.x += forceX;
    velocity.y += forceY;

    velocity.x *= friction;
    velocity.y *= friction;

    handle.x += velocity.x;
    handle.y += velocity.y;
  }

  draw();
  requestAnimationFrame(updatePhysics);
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Corda
  ctx.beginPath();
  ctx.moveTo(origin.x, origin.y);
  ctx.lineTo(handle.x, handle.y);
  ctx.strokeStyle = "#444";
  ctx.lineWidth = 4;
  ctx.stroke();

  // Luz ao redor (efeito glow ao mudar tema)
  if (pulled) {
    const gradient = ctx.createRadialGradient(handle.x, handle.y, 10, handle.x, handle.y, 40);
    gradient.addColorStop(0, "rgba(255, 255, 100, 0.8)");
    gradient.addColorStop(1, "rgba(255, 255, 100, 0)");
    ctx.beginPath();
    ctx.arc(handle.x, handle.y, 40, 0, Math.PI * 2);
    ctx.fillStyle = gradient;
    ctx.fill();
  }

  // AlÃ§a
  ctx.beginPath();
  ctx.arc(handle.x, handle.y, 25, 0, Math.PI * 2);
  ctx.fillStyle = "#999";
  ctx.fill();

  // Emoji no centro
  ctx.font = "20px sans-serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  const emoji = document.body.classList.contains("dark") ? "ðŸŒ™" : "ðŸŒž";
  ctx.fillText(emoji, handle.x, handle.y);
}



restoreTheme();
updatePhysics();
</script>

</body>

</html>